This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: wm/**/*, web/src/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
web/
  src/
    app/
      favicon.ico
      globals.css
      layout.tsx
      page.tsx
    hooks/
      useVM.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="web/src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="web/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="web/src/app/page.tsx">
"use client";

import {
  useEffect,
  useRef,
} from "react";
import { useVM } from "../hooks/useVM";

export default function Home() {
  const { output, status, sendInput, cpuLoad, memUsage } = useVM();
  const endRef = useRef<HTMLDivElement>(null);

  // Auto scroll
  useEffect(() => {
    endRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [output]);

  // Global key handler so you can still type anywhere on the page
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.metaKey || e.ctrlKey || e.altKey) return;

      // Don't double-handle keys when an input/textarea/contenteditable has focus
      const target = e.target as HTMLElement | null;
      if (target) {
        const tag = target.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA" || target.isContentEditable) {
          return;
        }
      }

      if (e.key.length === 1 || e.key === "Enter" || e.key === "Backspace") {
        e.preventDefault();
        sendInput(e.key);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [sendInput]);

  return (
    <div className="min-h-screen bg-black text-green-500 p-4 font-mono text-lg flex flex-col">
      <div className="mb-2 border-b border-green-700 pb-2 flex justify-between">
        <h1 className="font-bold">RISC-V VM</h1>
        <div className="flex gap-4 items-center">
          <span className="text-sm text-green-400">
            CPU: {cpuLoad.toFixed(0)}%
          </span>
          <span className="text-sm text-green-400">
            MEM: {(memUsage / (1024 * 1024)).toFixed(1)} MiB
          </span>
          <span
            className={status === "Running" ? "text-green-500" : "text-red-500"}
          >
            [{status}]
          </span>
        </div>
      </div>

      <div className="flex-grow whitespace-pre-wrap break-all focus:outline-none" tabIndex={0}>
        {output}
        <span className="animate-pulse">_</span>
        <div ref={endRef} />
      </div>
      
      <div className="mt-2 text-xs text-gray-500">
          Type anywhere to send input to the VM.
      </div>
    </div>
  );
}
</file>

<file path="web/src/hooks/useVM.ts">
import { useEffect, useRef, useState, useCallback } from 'react';
import init, { WasmVm } from '../pkg/vm';

export function useVM() {
  const vmRef = useRef<WasmVm | null>(null);
  const [output, setOutput] = useState<string>("");
  const [status, setStatus] = useState<string>("Initializing...");
  const requestRef = useRef<number | null>(null);
  const [cpuLoad, setCpuLoad] = useState<number>(0);
  const [memUsage, setMemUsage] = useState<number>(0);

  useEffect(() => {
    let active = true;

    async function start() {
      try {
        // Let the bundler resolve the correct wasm asset path.
        await init('/vm_bg.wasm');
        
        if (!active) return;

        const res = await fetch('/kernel.bin');
        if (!res.ok) throw new Error(`Failed to load kernel: ${res.statusText}`);
        const buf = await res.arrayBuffer();
        const bytes = new Uint8Array(buf);
        
        const vm = new WasmVm(bytes);
        vmRef.current = vm;
        setStatus("Running");
        
        loop();
      } catch (err: any) {
        if (active) setStatus(`Error: ${err.message || err}`);
      }
    }
    start();
    
    return () => {
      active = false;
      if (requestRef.current !== null) cancelAnimationFrame(requestRef.current);
    };
  }, []);

  const loop = () => {
    const vm = vmRef.current;
    if (!vm) return;

    const INSTRUCTIONS_PER_FRAME = 5000; 
    
    try {
      const t0 = performance.now();
      for (let i = 0; i < INSTRUCTIONS_PER_FRAME; i++) {
        vm.step();
      }
      const t1 = performance.now();
      const duration = t1 - t0;
      const load = Math.min(100, (duration / 16.67) * 100);
      setCpuLoad(load);
      
      // Query memory usage if the wasm exposes it
      const anyVm = vm as any;
      if (typeof anyVm.get_memory_usage === 'function') {
        const usage = Number(anyVm.get_memory_usage());
        setMemUsage(usage);
      }
      
      // Drain output buffer (sanitize control chars)
      const codes: number[] = [];
      let ch = (vm as any).get_output?.();
      let limit = 2000;
      while (ch !== undefined && limit > 0) {
        codes.push(Number(ch));
        ch = (vm as any).get_output?.();
        limit--;
      }

      if (codes.length) {
        setOutput(prev => {
          let current = prev;
          for (const code of codes) {
            if (code === 8) {
              // Backspace
              current = current.slice(0, -1);
            } else if (code === 10 || code === 13 || (code >= 32 && code <= 126)) {
              current += String.fromCharCode(code);
            } else {
              // Drop other control bytes
            }
          }
          return current;
        });
      }
      
      requestRef.current = requestAnimationFrame(loop);
    } catch (e: any) {
      setStatus(`Crashed: ${e}`);
      console.error(e);
    }
  };

  const sendInput = useCallback((key: string) => {
    const vm = vmRef.current;
    if (!vm) return;
    
    // Map Enter to \n
    if (key === 'Enter') {
        vm.input(10); // \n
        return;
    }

    // Map Backspace to 8
    if (key === 'Backspace') {
        vm.input(8);
        return;
    }
    
    if (key.length === 1) {
        vm.input(key.charCodeAt(0));
    }
  }, []);

  return { output, status, sendInput, cpuLoad, memUsage };
}
</file>

</files>
